# 设计模式

> 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 

代码写多了确实会发现一些好习惯,这些好习惯让代码:

- 更少bug
- 测试方便
- 更改方便
- 复用方便
- 合作方便

各模式源自诸位大神一行一行代码的积累，皆为经验之谈，总结出来后可作为编码指导，亦可作为合作约定。

背景是为了讲解面向对象写法，不过在其他方式也相通的。

## 设计模式原则

参考文章:

- [设计模式六大原则 ](http://www.uml.org.cn/sjms/201211023.asp#2)
- [菜鸟教程-设计模式](http://www.runoob.com/design-pattern/design-pattern-intro.html)

大多会讲到6个原则,但上面两篇文章发现7个不同的原则

> **1、开闭原则（Open Close Principle）**
>
> 开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
>
> **2、里氏代换原则（Liskov Substitution Principle）**
>
> 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
>
> **3、依赖倒转原则（Dependence Inversion Principle）**
>
> 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
>
> **4、接口隔离原则（Interface Segregation Principle）**
>
> 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
>
> **5、迪米特法则，又称最少知道原则（Demeter Principle）**
>
> 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
>
> **6、合成复用原则（Composite Reuse Principle）**
>
> 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

还有一个原则

> 单一职责原则

### 开闭原则

> 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

开闭原则是六大原则的总纲，最为抽象。其他原则都是对开闭原则的深入和聚焦。

对拓展开放，意味着项目有着充分的发展空间。后续修改和添加功能不会受到太多限制。

对修改关闭，则让代码建立在稳固的地基上。

难怪这些术语会借鉴建筑行业，两者确实有相似之处。代码规模如同建筑规模：当规模较小时，它们都可以随意一点，但规模大了却要一步步考虑精细：

### 单一职责原则

> 定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。  

模块和其他兄弟模块不要相互影响。

模块和父子模块之间的关系要合理抽象。

添加和修改的时候最好不要修改之前的代码。

### 里氏替换原则 

> 其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。 

> 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。

就是说，T1是一个类，里面有很多对象，利用这些类你可以制造一个应用，制造的所有应用集合为p。T2的对象全部被对应的T2对象替换后，程序并不发生变化，那么T2是T1的子类型。

这段定义似乎，没什么好挑剔的。但有点像“如果一个东西长得像鸭子，叫得像鸭子，走路也是鸭子，那它就是鸭子”。

> 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 

翻译得有点难懂。

不过意思就是添加新功能时不改变原有的方法。这也好理解，毕竟父类被继承之后可能会用到多个地方，如果被修改了可能会引起大范围事故。

> 如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。 

> 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
>
> - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
> - 子类中可以增加自己特有的方法。
> - 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
> - 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

### 依赖导致原则

> 定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 

> 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。 

[这篇文字讲得不错](http://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650588872&idx=1&sn=db86390b56263c1860e4dcf978971964&chksm=8891d6ecbfe65ffaf49377a70e1d5889dd367e1d4fc883351692820689aba9f611ba5441fc0f&mpshare=1&scene=1&srcid=#rd)

> 采用依赖倒置原则给多人并行开发带来了极大的便利

> 现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。 

> 以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递 

> - 低层模块尽量都要有抽象类或接口，或者两者都有。
> - 变量的声明类型尽量是抽象类或接口。
> - 使用继承时遵循里氏替换原则。

### 接口隔离原则

> 定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 
> 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
>
> 解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

> 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 

像是某种乐高积木游戏。比如模块a和模块b可以组合成一个积木小飞机，模块b和模块c可以组成小飞船。如果只为了组成这两个玩具，那么不需要abc三个模块一起买两次，但也不要买各自买很多分散的小模块。因为在这里假设小孩子太傻，太分散了就不会玩。

### 迪米特原则

#### 尽量少耦合

> 定义：一个对象应该对其他对象保持最少的了解。 

低耦合高内聚。

> 迪米特法则还有一个更简单的定义：只与直接的朋友通信。 首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 

成员变量:Java中才成员变量大概类似于js中对象的属性或方法，用prototype来封装时会很常用。

方法参数，方法返回值和js中的一样吧，就是函数作为实参。



基本上就是这样了。